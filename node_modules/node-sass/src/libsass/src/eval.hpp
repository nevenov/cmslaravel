#ifndef SASS_EVAL_H
#define SASS_EVAL_H

#include "ast.hpp"
#include "context.hpp"
<<<<<<< HEAD
=======
#include "listize.hpp"
>>>>>>> dev
#include "operation.hpp"
#include "environment.hpp"

namespace Sass {

  class Expand;
  class Context;

<<<<<<< HEAD
  class Eval : public Operation_CRTP<Expression*, Eval> {

   private:
    Expression* fallback_impl(AST_Node* n);

   public:
    Expand&  exp;
    Context& ctx;
    Eval(Expand& exp);
    ~Eval();

    bool is_in_comment;

    Env* environment();
    Context& context();
    Selector_List* selector();
    Backtrace* backtrace();

    // for evaluating function bodies
    Expression* operator()(Block*);
    Expression* operator()(Assignment*);
    Expression* operator()(If*);
    Expression* operator()(For*);
    Expression* operator()(Each*);
    Expression* operator()(While*);
    Expression* operator()(Return*);
    Expression* operator()(Warning*);
    Expression* operator()(Error*);
    Expression* operator()(Debug*);

    Expression* operator()(List*);
    Expression* operator()(Map*);
    Expression* operator()(Binary_Expression*);
    Expression* operator()(Unary_Expression*);
    Expression* operator()(Function_Call*);
    Expression* operator()(Function_Call_Schema*);
    Expression* operator()(Variable*);
    Expression* operator()(Textual*);
    Expression* operator()(Number*);
    Expression* operator()(Boolean*);
    Expression* operator()(String_Schema*);
    Expression* operator()(String_Quoted*);
    Expression* operator()(String_Constant*);
    // Expression* operator()(Selector_List*);
    Expression* operator()(Media_Query*);
    Expression* operator()(Media_Query_Expression*);
    Expression* operator()(At_Root_Query*);
    Expression* operator()(Supports_Operator*);
    Expression* operator()(Supports_Negation*);
    Expression* operator()(Supports_Declaration*);
    Expression* operator()(Supports_Interpolation*);
    Expression* operator()(Null*);
    Expression* operator()(Argument*);
    Expression* operator()(Arguments*);
    Expression* operator()(Comment*);

    // these will return selectors
    Selector_List* operator()(Selector_List*);
    Selector_List* operator()(Complex_Selector*);
    Attribute_Selector* operator()(Attribute_Selector*);
    // they don't have any specific implementatio (yet)
    Type_Selector* operator()(Type_Selector* s) { return s; };
    Pseudo_Selector* operator()(Pseudo_Selector* s) { return s; };
    Wrapped_Selector* operator()(Wrapped_Selector* s) { return s; };
    Selector_Qualifier* operator()(Selector_Qualifier* s) { return s; };
    Selector_Placeholder* operator()(Selector_Placeholder* s) { return s; };
    // actual evaluated selectors
    Selector_List* operator()(Selector_Schema*);
    Expression* operator()(Parent_Selector*);

    template <typename U>
    Expression* fallback(U x) { return fallback_impl(x); }

    // -- only need to define two comparisons, and the rest can be implemented in terms of them
    static bool eq(Expression*, Expression*);
    static bool lt(Expression*, Expression*, std::string op);
    // -- arithmetic on the combinations that matter
    static Value* op_numbers(Memory_Manager&, enum Sass_OP, const Number&, const Number&, struct Sass_Inspect_Options opt, ParserState* pstate = 0);
    static Value* op_number_color(Memory_Manager&, enum Sass_OP, const Number&, const Color&, struct Sass_Inspect_Options opt, ParserState* pstate = 0);
    static Value* op_color_number(Memory_Manager&, enum Sass_OP, const Color&, const Number&, struct Sass_Inspect_Options opt, ParserState* pstate = 0);
    static Value* op_colors(Memory_Manager&, enum Sass_OP, const Color&, const Color&, struct Sass_Inspect_Options opt, ParserState* pstate = 0);
    static Value* op_strings(Memory_Manager&, Sass::Operand, Value&, Value&, struct Sass_Inspect_Options opt, ParserState* pstate = 0, bool interpolant = false);

  private:
    void interpolation(Context& ctx, std::string& res, Expression* ex, bool into_quotes, bool was_itpl = false);

  };

  Expression* cval_to_astnode(Memory_Manager& mem, union Sass_Value* v, Context& ctx, Backtrace* backtrace, ParserState pstate = ParserState("[AST]"));
=======
  class Eval : public Operation_CRTP<Expression_Ptr, Eval> {

   private:
    Expression_Ptr fallback_impl(AST_Node_Ptr n);

   public:
    Expand& exp;
    Context& ctx;
    Backtraces& traces;
    Eval(Expand& exp);
    ~Eval();

    bool force;
    bool is_in_comment;
    bool is_in_selector_schema;

    Boolean_Obj bool_true;
    Boolean_Obj bool_false;

    Env* environment();
    Selector_List_Obj selector();

    // for evaluating function bodies
    Expression_Ptr operator()(Block_Ptr);
    Expression_Ptr operator()(Assignment_Ptr);
    Expression_Ptr operator()(If_Ptr);
    Expression_Ptr operator()(For_Ptr);
    Expression_Ptr operator()(Each_Ptr);
    Expression_Ptr operator()(While_Ptr);
    Expression_Ptr operator()(Return_Ptr);
    Expression_Ptr operator()(Warning_Ptr);
    Expression_Ptr operator()(Error_Ptr);
    Expression_Ptr operator()(Debug_Ptr);

    Expression_Ptr operator()(List_Ptr);
    Expression_Ptr operator()(Map_Ptr);
    Expression_Ptr operator()(Binary_Expression_Ptr);
    Expression_Ptr operator()(Unary_Expression_Ptr);
    Expression_Ptr operator()(Function_Call_Ptr);
    Expression_Ptr operator()(Function_Call_Schema_Ptr);
    Expression_Ptr operator()(Variable_Ptr);
    Expression_Ptr operator()(Number_Ptr);
    Expression_Ptr operator()(Color_Ptr);
    Expression_Ptr operator()(Boolean_Ptr);
    Expression_Ptr operator()(String_Schema_Ptr);
    Expression_Ptr operator()(String_Quoted_Ptr);
    Expression_Ptr operator()(String_Constant_Ptr);
    // Expression_Ptr operator()(Selector_List_Ptr);
    Media_Query_Ptr operator()(Media_Query_Ptr);
    Expression_Ptr operator()(Media_Query_Expression_Ptr);
    Expression_Ptr operator()(At_Root_Query_Ptr);
    Expression_Ptr operator()(Supports_Operator_Ptr);
    Expression_Ptr operator()(Supports_Negation_Ptr);
    Expression_Ptr operator()(Supports_Declaration_Ptr);
    Expression_Ptr operator()(Supports_Interpolation_Ptr);
    Expression_Ptr operator()(Null_Ptr);
    Expression_Ptr operator()(Argument_Ptr);
    Expression_Ptr operator()(Arguments_Ptr);
    Expression_Ptr operator()(Comment_Ptr);

    // these will return selectors
    Selector_List_Ptr operator()(Selector_List_Ptr);
    Selector_List_Ptr operator()(Complex_Selector_Ptr);
    Compound_Selector_Ptr operator()(Compound_Selector_Ptr);
    Simple_Selector_Ptr operator()(Simple_Selector_Ptr s);
    Wrapped_Selector_Ptr operator()(Wrapped_Selector_Ptr s);
    // they don't have any specific implementation (yet)
    // Element_Selector_Ptr operator()(Element_Selector_Ptr s) { return s; };
    // Pseudo_Selector_Ptr operator()(Pseudo_Selector_Ptr s) { return s; };
    // Class_Selector_Ptr operator()(Class_Selector_Ptr s) { return s; };
    // Id_Selector_Ptr operator()(Id_Selector_Ptr s) { return s; };
    // Placeholder_Selector_Ptr operator()(Placeholder_Selector_Ptr s) { return s; };
    // actual evaluated selectors
    Selector_List_Ptr operator()(Selector_Schema_Ptr);
    Expression_Ptr operator()(Parent_Selector_Ptr);

    template <typename U>
    Expression_Ptr fallback(U x) { return fallback_impl(x); }

  private:
    void interpolation(Context& ctx, std::string& res, Expression_Obj ex, bool into_quotes, bool was_itpl = false);

  };

  Expression_Ptr cval_to_astnode(union Sass_Value* v, Backtraces traces, ParserState pstate = ParserState("[AST]"));
>>>>>>> dev

}

#endif
