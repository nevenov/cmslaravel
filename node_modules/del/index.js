'use strict';
<<<<<<< HEAD
var path = require('path');
var globby = require('globby');
var eachAsync = require('each-async');
var isPathCwd = require('is-path-cwd');
var isPathInCwd = require('is-path-in-cwd');
var rimraf = require('rimraf');
var objectAssign = require('object-assign');
=======
const path = require('path');
const globby = require('globby');
const isPathCwd = require('is-path-cwd');
const isPathInCwd = require('is-path-in-cwd');
const pify = require('pify');
const rimraf = require('rimraf');
const pMap = require('p-map');

const rimrafP = pify(rimraf);
>>>>>>> dev

function safeCheck(file) {
	if (isPathCwd(file)) {
		throw new Error('Cannot delete the current working directory. Can be overriden with the `force` option.');
	}

	if (!isPathInCwd(file)) {
		throw new Error('Cannot delete files/folders outside the current working directory. Can be overriden with the `force` option.');
	}
}

<<<<<<< HEAD
module.exports = function (patterns, opts, cb) {
	if (typeof opts !== 'object') {
		cb = opts;
		opts = {};
	}

	opts = objectAssign({}, opts);
	cb = cb || function () {};

	var force = opts.force;
	delete opts.force;

	var deletedFiles = [];

	globby(patterns, opts, function (err, files) {
		if (err) {
			cb(err);
			return;
		}

		eachAsync(files, function (el, i, next) {
			if (!force) {
				safeCheck(el);
			}

			el = path.resolve(opts.cwd || '', el);
			deletedFiles.push(el);
			rimraf(el, next);
		}, function (err) {
			if (err) {
				cb(err);
				return;
			}

			cb(null, deletedFiles);
		});
	});
};

module.exports.sync = function (patterns, opts) {
	opts = objectAssign({}, opts);

	var force = opts.force;
	delete opts.force;

	var deletedFiles = [];

	globby.sync(patterns, opts).forEach(function (el) {
		if (!force) {
			safeCheck(el);
		}

		el = path.resolve(opts.cwd || '', el);
		deletedFiles.push(el);
		rimraf.sync(el);
	});

	return deletedFiles;
=======
module.exports = (patterns, opts) => {
	opts = Object.assign({}, opts);

	const force = opts.force;
	delete opts.force;

	const dryRun = opts.dryRun;
	delete opts.dryRun;

	const mapper = file => {
		if (!force) {
			safeCheck(file);
		}

		file = path.resolve(opts.cwd || '', file);

		if (dryRun) {
			return file;
		}

		return rimrafP(file, {glob: false}).then(() => file);
	};

	return globby(patterns, opts).then(files => pMap(files, mapper, opts));
};

module.exports.sync = (patterns, opts) => {
	opts = Object.assign({}, opts);

	const force = opts.force;
	delete opts.force;

	const dryRun = opts.dryRun;
	delete opts.dryRun;

	return globby.sync(patterns, opts).map(file => {
		if (!force) {
			safeCheck(file);
		}

		file = path.resolve(opts.cwd || '', file);

		if (!dryRun) {
			rimraf.sync(file, {glob: false});
		}

		return file;
	});
>>>>>>> dev
};
